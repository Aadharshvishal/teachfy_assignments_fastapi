ENV.PY

from logging.config import fileConfig
from sqlalchemy import engine_from_config
from sqlalchemy import pool
from alembic import context
import os
import sys

# Add the project root to the Python path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from database import Base
from models.models import Author, Book

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# add your model's MetaData object here
# for 'autogenerate' support
target_metadata = Base.metadata

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    connectable = engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection, target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()


MODELS.PY

from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Text, Boolean
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from database import Base

class Author(Base):
    __tablename__ = "authors"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100), nullable=False, index=True)
    email = Column(String(100), unique=True, nullable=False, index=True)
    bio = Column(Text, nullable=True)
    birth_date = Column(DateTime, nullable=True)
    is_active = Column(Boolean, default=True, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())
    
    # One-to-many relationship with books
    books = relationship("Book", back_populates="author", cascade="all, delete-orphan")

class Book(Base):
    __tablename__ = "books"
    
    id = Column(Integer, primary_key=True, index=True)
    title = Column(String(200), nullable=False, index=True)
    description = Column(Text, nullable=True)
    isbn = Column(String(20), unique=True, nullable=True, index=True)
    publication_date = Column(DateTime, nullable=True)
    price = Column(String(20), nullable=True)  # Using string for price to handle currency
    is_published = Column(Boolean, default=False, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())
    
    # Foreign key to author
    author_id = Column(Integer, ForeignKey("authors.id"), nullable=False, index=True)
    
    # Many-to-one relationship with author
    author = relationship("Author", back_populates="books")


AUTHORS.PY

from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.orm import Session
from typing import List, Optional
from database import get_db
from models.models import Author
from schemas.schemas import AuthorCreate, AuthorUpdate, Author as AuthorSchema, AuthorWithBooks

router = APIRouter(prefix="/authors", tags=["authors"])

@router.get("/", response_model=List[AuthorSchema])
def get_authors(
    skip: int = Query(0, ge=0, description="Number of authors to skip"),
    limit: int = Query(100, ge=1, le=1000, description="Maximum number of authors to return"),
    name: Optional[str] = Query(None, description="Filter by author name (partial match)"),
    email: Optional[str] = Query(None, description="Filter by author email (partial match)"),
    is_active: Optional[bool] = Query(None, description="Filter by active status"),
    db: Session = Depends(get_db)
):
    """Get all authors with filtering and pagination"""
    query = db.query(Author)
    
    # Apply filters
    if name:
        query = query.filter(Author.name.ilike(f"%{name}%"))
    if email:
        query = query.filter(Author.email.ilike(f"%{email}%"))
    if is_active is not None:
        query = query.filter(Author.is_active == is_active)
    
    # Apply pagination
    authors = query.offset(skip).limit(limit).all()
    return authors

@router.get("/{author_id}", response_model=AuthorWithBooks)
def get_author(author_id: int, db: Session = Depends(get_db)):
    """Get a specific author by ID with their books"""
    author = db.query(Author).filter(Author.id == author_id).first()
    if not author:
        raise HTTPException(status_code=404, detail="Author not found")
    return author

@router.post("/", response_model=AuthorSchema, status_code=status.HTTP_201_CREATED)
def create_author(author: AuthorCreate, db: Session = Depends(get_db)):
    """Create a new author"""
    # Check if email already exists
    existing_author = db.query(Author).filter(Author.email == author.email).first()
    if existing_author:
        raise HTTPException(status_code=400, detail="Email already registered")
    
    db_author = Author(**author.dict())
    db.add(db_author)
    db.commit()
    db.refresh(db_author)
    return db_author

@router.put("/{author_id}", response_model=AuthorSchema)
def update_author(author_id: int, author: AuthorUpdate, db: Session = Depends(get_db)):
    """Update an author"""
    db_author = db.query(Author).filter(Author.id == author_id).first()
    if not db_author:
        raise HTTPException(status_code=404, detail="Author not found")
    
    # Check if email is being updated and if it already exists
    if author.email and author.email != db_author.email:
        existing_author = db.query(Author).filter(Author.email == author.email).first()
        if existing_author:
            raise HTTPException(status_code=400, detail="Email already registered")
    
    # Update only provided fields
    update_data = author.dict(exclude_unset=True)
    for field, value in update_data.items():
        setattr(db_author, field, value)
    
    db.commit()
    db.refresh(db_author)
    return db_author

@router.delete("/{author_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_author(author_id: int, db: Session = Depends(get_db)):
    """Delete an author (this will also delete all their books due to cascade)"""
    author = db.query(Author).filter(Author.id == author_id).first()
    if not author:
        raise HTTPException(status_code=404, detail="Author not found")
    
    db.delete(author)
    db.commit()
    return None

@router.get("/{author_id}/books", response_model=List[dict])
def get_author_books(author_id: int, db: Session = Depends(get_db)):
    """Get all books by a specific author"""
    author = db.query(Author).filter(Author.id == author_id).first()
    if not author:
        raise HTTPException(status_code=404, detail="Author not found")
    
    books = db.query(Author).filter(Author.id == author_id).first().books
    return books


BOOKS.PY

from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.orm import Session
from sqlalchemy import and_
from typing import List, Optional
from database import get_db
from models.models import Book, Author
from schemas.schemas import BookCreate, BookUpdate, Book as BookSchema

router = APIRouter(prefix="/books", tags=["books"])

@router.get("/", response_model=List[BookSchema])
def get_books(
    skip: int = Query(0, ge=0, description="Number of books to skip"),
    limit: int = Query(100, ge=1, le=1000, description="Maximum number of books to return"),
    title: Optional[str] = Query(None, description="Filter by book title (partial match)"),
    isbn: Optional[str] = Query(None, description="Filter by ISBN"),
    author_id: Optional[int] = Query(None, description="Filter by author ID"),
    author_name: Optional[str] = Query(None, description="Filter by author name (partial match)"),
    is_published: Optional[bool] = Query(None, description="Filter by published status"),
    min_price: Optional[float] = Query(None, description="Minimum price filter"),
    max_price: Optional[float] = Query(None, description="Maximum price filter"),
    db: Session = Depends(get_db)
):
    """Get all books with filtering and pagination"""
    query = db.query(Book)
    
    # Apply filters
    if title:
        query = query.filter(Book.title.ilike(f"%{title}%"))
    if isbn:
        query = query.filter(Book.isbn.ilike(f"%{isbn}%"))
    if author_id:
        query = query.filter(Book.author_id == author_id)
    if author_name:
        query = query.join(Author).filter(Author.name.ilike(f"%{author_name}%"))
    if is_published is not None:
        query = query.filter(Book.is_published == is_published)
    if min_price is not None:
        query = query.filter(Book.price.isnot(None))
        # Note: In a real app, you'd parse price strings to float for comparison
    if max_price is not None:
        query = query.filter(Book.price.isnot(None))
        # Note: In a real app, you'd parse price strings to float for comparison
    
    # Apply pagination
    books = query.offset(skip).limit(limit).all()
    return books

@router.get("/{book_id}", response_model=BookSchema)
def get_book(book_id: int, db: Session = Depends(get_db)):
    """Get a specific book by ID"""
    book = db.query(Book).filter(Book.id == book_id).first()
    if not book:
        raise HTTPException(status_code=404, detail="Book not found")
    return book

@router.post("/", response_model=BookSchema, status_code=status.HTTP_201_CREATED)
def create_book(book: BookCreate, db: Session = Depends(get_db)):
    """Create a new book"""
    # Check if author exists
    author = db.query(Author).filter(Author.id == book.author_id).first()
    if not author:
        raise HTTPException(status_code=400, detail="Author not found")
    
    # Check if ISBN already exists (if provided)
    if book.isbn:
        existing_book = db.query(Book).filter(Book.isbn == book.isbn).first()
        if existing_book:
            raise HTTPException(status_code=400, detail="ISBN already exists")
    
    db_book = Book(**book.dict())
    db.add(db_book)
    db.commit()
    db.refresh(db_book)
    return db_book

@router.put("/{book_id}", response_model=BookSchema)
def update_book(book_id: int, book: BookUpdate, db: Session = Depends(get_db)):
    """Update a book"""
    db_book = db.query(Book).filter(Book.id == book_id).first()
    if not db_book:
        raise HTTPException(status_code=404, detail="Book not found")
    
    # Check if author exists (if being updated)
    if book.author_id and book.author_id != db_book.author_id:
        author = db.query(Author).filter(Author.id == book.author_id).first()
        if not author:
            raise HTTPException(status_code=400, detail="Author not found")
    
    # Check if ISBN already exists (if being updated)
    if book.isbn and book.isbn != db_book.isbn:
        existing_book = db.query(Book).filter(Book.isbn == book.isbn).first()
        if existing_book:
            raise HTTPException(status_code=400, detail="ISBN already exists")
    
    # Update only provided fields
    update_data = book.dict(exclude_unset=True)
    for field, value in update_data.items():
        setattr(db_book, field, value)
    
    db.commit()
    db.refresh(db_book)
    return db_book

@router.delete("/{book_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_book(book_id: int, db: Session = Depends(get_db)):
    """Delete a book"""
    book = db.query(Book).filter(Book.id == book_id).first()
    if not book:
        raise HTTPException(status_code=404, detail="Book not found")
    
    db.delete(book)
    db.commit()
    return None

@router.get("/search/advanced", response_model=List[BookSchema])
def advanced_search(
    q: Optional[str] = Query(None, description="Search query for title and description"),
    author_id: Optional[int] = Query(None, description="Filter by author ID"),
    is_published: Optional[bool] = Query(None, description="Filter by published status"),
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=1000),
    db: Session = Depends(get_db)
):
    """Advanced search with multiple filters"""
    query = db.query(Book)
    
    if q:
        query = query.filter(
            and_(
                Book.title.ilike(f"%{q}%"),
                Book.description.ilike(f"%{q}%")
            )
        )
    if author_id:
        query = query.filter(Book.author_id == author_id)
    if is_published is not None:
        query = query.filter(Book.is_published == is_published)
    
    books = query.offset(skip).limit(limit).all()
    return books


SCHEMAS.PY

from pydantic import BaseModel, EmailStr
from typing import Optional, List
from datetime import datetime

# Author Schemas
class AuthorBase(BaseModel):
    name: str
    email: str  # Using simple string instead of EmailStr to avoid email-validator dependency
    bio: Optional[str] = None
    birth_date: Optional[datetime] = None
    is_active: bool = True

class AuthorCreate(AuthorBase):
    pass

class AuthorUpdate(BaseModel):
    name: Optional[str] = None
    email: Optional[str] = None  # Using simple string instead of EmailStr
    bio: Optional[str] = None
    birth_date: Optional[datetime] = None
    is_active: Optional[bool] = None

class Author(AuthorBase):
    id: int
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True

class AuthorWithBooks(Author):
    books: List['Book'] = []

# Book Schemas
class BookBase(BaseModel):
    title: str
    description: Optional[str] = None
    isbn: Optional[str] = None
    publication_date: Optional[datetime] = None
    price: Optional[str] = None
    is_published: bool = False
    author_id: int

class BookCreate(BookBase):
    pass

class BookUpdate(BaseModel):
    title: Optional[str] = None
    description: Optional[str] = None
    isbn: Optional[str] = None
    publication_date: Optional[datetime] = None
    price: Optional[str] = None
    is_published: Optional[bool] = None
    author_id: Optional[int] = None

class Book(BookBase):
    id: int
    created_at: datetime
    updated_at: datetime
    author: Optional[Author] = None
    
    class Config:
        from_attributes = True

# Update forward references
AuthorWithBooks.model_rebuild()
Book.model_rebuild()


DATABASE.PY

from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

# Database URL - Update this to your PostgreSQL connection
SQLALCHEMY_DATABASE_URL = 'postgresql://postgres:swagath12345@localhost/fastapi'

# Create engine
engine = create_engine(SQLALCHEMY_DATABASE_URL)

# Create SessionLocal class
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Create Base class
Base = declarative_base()

def get_db():
    """Dependency to get database session"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

def create_tables():
    """Create all tables"""
    Base.metadata.create_all(bind=engine)

def drop_tables():
    """Drop all tables"""
    Base.metadata.drop_all(bind=engine)


MAIN.PY

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from database import create_tables
from routers import authors, books

# Create FastAPI application
app = FastAPI(
    title="Assignment 2 - Core API & Database",
    version="1.0.0",
    description="A FastAPI application with Authors and Books resources, PostgreSQL database, and one-to-many relationships"
)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include routers
app.include_router(authors.router)
app.include_router(books.router)

@app.on_event("startup")
async def startup_event():
    """Create tables on startup"""
    create_tables()

@app.get("/")
def read_root():
    """Root endpoint"""
    return {
        "message": "Assignment 2 - Core API & Database",
        "version": "1.0.0",
        "description": "Authors and Books API with PostgreSQL database",
        "docs": "/docs",
        "endpoints": {
            "authors": "/authors",
            "books": "/books"
        }
    }

@app.get("/health")
def health_check():
    """Health check endpoint"""
    return {
        "status": "healthy",
        "message": "Assignment 2 API is running successfully",
        "database": "PostgreSQL",
        "features": [
            "Authors CRUD operations",
            "Books CRUD operations", 
            "One-to-many relationship (Author -> Books)",
            "Query parameter filtering",
            "Alembic migrations",
            "PostgreSQL database"
        ]
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="127.0.0.1", port=8000)


TEST_ASSIGNMENT2.PY

#!/usr/bin/env python3
"""
Test script to verify Assignment 2 setup is working correctly.
Run this script to test all endpoints and verify the FastAPI server is functioning.
"""

import requests
import json
import sys
from typing import Dict, Any

def test_endpoint(url: str, method: str = "GET", data: Dict = None, expected_status: int = 200) -> Dict[str, Any]:
    """Test a single endpoint and return the result."""
    try:
        if method == "GET":
            response = requests.get(url, timeout=5)
        elif method == "POST":
            response = requests.post(url, json=data, timeout=5)
        elif method == "PUT":
            response = requests.put(url, json=data, timeout=5)
        elif method == "DELETE":
            response = requests.delete(url, timeout=5)
        else:
            return {
                "url": url,
                "method": method,
                "status_code": None,
                "success": False,
                "error": f"Unsupported method: {method}"
            }
        
        return {
            "url": url,
            "method": method,
            "status_code": response.status_code,
            "success": response.status_code == expected_status,
            "data": response.json() if response.headers.get('content-type', '').startswith('application/json') else response.text[:200]
        }
    except requests.exceptions.RequestException as e:
        return {
            "url": url,
            "method": method,
            "status_code": None,
            "success": False,
            "error": str(e)
        }

def cleanup_test_data(base_url):
    """Clean up any existing test data to avoid conflicts"""
    try:
        # Get all authors and books
        authors_response = requests.get(f"{base_url}/authors", timeout=5)
        books_response = requests.get(f"{base_url}/books", timeout=5)
        
        if authors_response.status_code == 200:
            authors = authors_response.json()
            # Delete all test authors
            for author in authors:
                if "test.author" in author.get("email", ""):
                    requests.delete(f"{base_url}/authors/{author['id']}", timeout=5)
        
        if books_response.status_code == 200:
            books = books_response.json()
            # Delete all test books
            for book in books:
                if "Test Book" in book.get("title", ""):
                    requests.delete(f"{base_url}/books/{book['id']}", timeout=5)
    except:
        pass  # Ignore cleanup errors

def main():
    """Run all tests for Assignment 2 setup."""
    print("=== Assignment 2 - Core API & Database Test ===")
    print("Testing FastAPI server with Authors and Books endpoints...")
    print()
    
    base_url = "http://127.0.0.1:8000"
    
    # Clean up any existing test data
    print("Cleaning up any existing test data...")
    cleanup_test_data(base_url)
    print()
    
    # Test basic endpoints first
    basic_endpoints = [
        ("/", "GET", "Root endpoint"),
        ("/health", "GET", "Health check endpoint"),
        ("/authors", "GET", "Get all authors"),
        ("/books", "GET", "Get all books"),
    ]
    
    # Test data for POST requests - using unique identifiers to avoid conflicts
    import time
    timestamp = int(time.time())
    
    author_data = {
        "name": f"Test Author {timestamp}",
        "email": f"test.author.{timestamp}@example.com",
        "bio": "A test author for testing purposes",
        "is_active": True
    }
    
    book_data = {
        "title": f"Test Book {timestamp}",
        "description": "A test book for testing purposes",
        "isbn": f"978-{timestamp}",
        "is_published": True,
        "author_id": 1  # This will be updated after author creation
    }
    
    results = []
    all_passed = True
    
    # Test basic endpoints first
    for endpoint, method, description in basic_endpoints:
        print(f"Testing {description} ({method} {base_url}{endpoint})...")
        result = test_endpoint(f"{base_url}{endpoint}", method)
        results.append(result)
        
        if result["success"]:
            print(f"‚úÖ {description} - Status: {result['status_code']}")
            print(f"   Response: {json.dumps(result['data'], indent=2)}")
        else:
            print(f"‚ùå {description} - Failed")
            if "error" in result:
                print(f"   Error: {result['error']}")
            else:
                print(f"   Status: {result['status_code']}")
            all_passed = False
        print()
    
    # Test POST endpoints (create data)
    print("Testing POST endpoints (creating test data)...")
    
    # Create author
    print("Creating test author...")
    author_result = test_endpoint(f"{base_url}/authors", "POST", author_data, 201)
    results.append(author_result)
    
    if author_result["success"]:
        print(f"‚úÖ Author created - Status: {author_result['status_code']}")
        author_id = author_result['data']['id']
        print(f"   Author ID: {author_id}")
        
        # Update book data with real author ID
        book_data["author_id"] = author_id
        
        # Create book
        print("Creating test book...")
        book_result = test_endpoint(f"{base_url}/books", "POST", book_data, 201)
        results.append(book_result)
        
        if book_result["success"]:
            print(f"‚úÖ Book created - Status: {book_result['status_code']}")
            book_id = book_result['data']['id']
            print(f"   Book ID: {book_id}")
        else:
            print(f"‚ùå Book creation failed")
            if "error" in book_result:
                print(f"   Error: {book_result['error']}")
            all_passed = False
    else:
        print(f"‚ùå Author creation failed")
        if "error" in author_result:
            print(f"   Error: {author_result['error']}")
        all_passed = False
    
    print()
    
    # Test GET by ID endpoints after creating data (only if creation was successful)
    if author_result["success"] and book_result["success"]:
        print("Testing GET by ID endpoints (verifying created data)...")
        
        # Test get author by ID
        print(f"Testing Get author by ID (GET {base_url}/authors/{author_id})...")
        author_get_result = test_endpoint(f"{base_url}/authors/{author_id}", "GET")
        results.append(author_get_result)
        
        if author_get_result["success"]:
            print(f"‚úÖ Get author by ID - Status: {author_get_result['status_code']}")
            print(f"   Author: {author_get_result['data']['name']}")
        else:
            print(f"‚ùå Get author by ID - Failed")
            if "error" in author_get_result:
                print(f"   Error: {author_get_result['error']}")
            else:
                print(f"   Status: {author_get_result['status_code']}")
            all_passed = False
        print()
        
        # Test get book by ID
        print(f"Testing Get book by ID (GET {base_url}/books/{book_id})...")
        book_get_result = test_endpoint(f"{base_url}/books/{book_id}", "GET")
        results.append(book_get_result)
        
        if book_get_result["success"]:
            print(f"‚úÖ Get book by ID - Status: {book_get_result['status_code']}")
            print(f"   Book: {book_get_result['data']['title']}")
        else:
            print(f"‚ùå Get book by ID - Failed")
            if "error" in book_get_result:
                print(f"   Error: {book_get_result['error']}")
            else:
                print(f"   Status: {book_get_result['status_code']}")
            all_passed = False
        print()
    else:
        print("Skipping GET by ID tests due to creation failures...")
        print()
    
    # Summary
    print("=== Test Summary ===")
    passed_count = sum(1 for r in results if r["success"])
    total_count = len(results)
    
    print(f"Tests passed: {passed_count}/{total_count}")
    
    if all_passed:
        print("üéâ All tests passed! Assignment 2 setup is working correctly.")
        print()
        print("Next steps:")
        print("1. Open http://127.0.0.1:8000/docs in your browser")
        print("2. Import postman_collection.json into Postman")
        print("3. Test all CRUD operations")
        print("4. Run Alembic migrations: alembic upgrade head")
        return 0
    else:
        print("‚ùå Some tests failed. Please check the server is running.")
        print("Make sure to run: uvicorn main:app --host 127.0.0.1 --port 8000")
        return 1

if __name__ == "__main__":
    sys.exit(main())
