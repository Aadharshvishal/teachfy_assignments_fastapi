Main.py file

from fastapi import FastAPI, Depends, HTTPException, status, Query
from sqlalchemy.orm import Session
from sqlalchemy import text, desc, asc
from database import engine, get_db, recreate_tables
from typing import List, Optional
import models
from pydantic import BaseModel
from datetime import datetime

# Create database tables with new schema (only if they don't exist)
from database import Base
Base.metadata.create_all(bind=engine)

# Pydantic models for request/response validation
class PostCreate(BaseModel):
    title: str
    content: str
    published: bool = True

class PostUpdate(BaseModel):
    title: Optional[str] = None
    content: Optional[str] = None
    published: Optional[bool] = None

class PostResponse(BaseModel):
    id: int
    title: str
    content: str
    published: bool
    created_at: datetime

    class Config:
        from_attributes = True

# User Pydantic models
class UserCreate(BaseModel):
    email: str
    password: str
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    is_active: bool = True
    is_verified: bool = False

class UserUpdate(BaseModel):
    email: Optional[str] = None
    password: Optional[str] = None
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    is_active: Optional[bool] = None
    is_verified: Optional[bool] = None

class UserResponse(BaseModel):
    id: int
    email: str
    first_name: Optional[str]
    last_name: Optional[str]
    is_active: bool
    is_verified: bool
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True

app = FastAPI(title="Blog API", version="1.0.0", description="A comprehensive Blog API with PostgreSQL integration")

@app.get("/")
def root():
    return {"message": "Blog API is running!", "version": "1.0.0", "docs": "/docs"}

@app.get("/posts", response_model=List[PostResponse])
def get_posts(
    db: Session = Depends(get_db),
    skip: int = Query(0, ge=0, description="Number of posts to skip"),
    limit: int = Query(100, ge=1, le=1000, description="Maximum number of posts to return"),
    published: Optional[bool] = Query(None, description="Filter by published status"),
    search: Optional[str] = Query(None, description="Search in title and content")
):
    """Get all posts with filtering, pagination, and search capabilities"""
    query = db.query(models.Post)
    
    # Apply filters
    if published is not None:
        query = query.filter(models.Post.published == published)
    
    if search:
        search_term = f"%{search}%"
        query = query.filter(
            (models.Post.title.ilike(search_term)) | 
            (models.Post.content.ilike(search_term))
        )
    
    # Apply pagination
    posts = query.offset(skip).limit(limit).all()
    return posts

@app.get("/posts/{post_id}", response_model=PostResponse)
def get_post(post_id: int, db: Session = Depends(get_db)):
    """Get a specific post by ID"""
    post = db.query(models.Post).filter(models.Post.id == post_id).first()
    if not post:
        raise HTTPException(status_code=404, detail=f"Post with id {post_id} not found")
    return post

@app.post("/posts", response_model=PostResponse, status_code=status.HTTP_201_CREATED)
def create_post(post: PostCreate, db: Session = Depends(get_db)):
    """Create a new post with validation"""
    new_post = models.Post(
        title=post.title,
        content=post.content,
        published=post.published
    )
    db.add(new_post)
    db.commit()
    db.refresh(new_post)
    return new_post

@app.put("/posts/{post_id}", response_model=PostResponse)
def update_post(post_id: int, post: PostUpdate, db: Session = Depends(get_db)):
    """Update a post with partial updates support"""
    db_post = db.query(models.Post).filter(models.Post.id == post_id).first()
    if not db_post:
        raise HTTPException(status_code=404, detail=f"Post with id {post_id} not found")
    
    # Only update provided fields
    if post.title is not None:
        db_post.title = post.title
    if post.content is not None:
        db_post.content = post.content
    if post.published is not None:
        db_post.published = post.published
    
    db.commit()
    db.refresh(db_post)
    return db_post

@app.delete("/posts/{post_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_post(post_id: int, db: Session = Depends(get_db)):
    """Delete a post"""
    post = db.query(models.Post).filter(models.Post.id == post_id).first()
    if not post:
        raise HTTPException(status_code=404, detail=f"Post with id {post_id} not found")
    
    db.delete(post)
    db.commit()
    return None

# User CRUD endpoints
@app.get("/users", response_model=List[UserResponse])
def get_users(
    db: Session = Depends(get_db),
    skip: int = Query(0, ge=0, description="Number of users to skip"),
    limit: int = Query(100, ge=1, le=1000, description="Maximum number of users to return"),
    is_active: Optional[bool] = Query(None, description="Filter by active status"),
    is_verified: Optional[bool] = Query(None, description="Filter by verification status")
):
    """Get all users with filtering and pagination"""
    query = db.query(models.User)
    
    # Apply filters
    if is_active is not None:
        query = query.filter(models.User.is_active == is_active)
    
    if is_verified is not None:
        query = query.filter(models.User.is_verified == is_verified)
    
    # Apply pagination
    users = query.offset(skip).limit(limit).all()
    return users

@app.get("/users/{user_id}", response_model=UserResponse)
def get_user(user_id: int, db: Session = Depends(get_db)):
    """Get a specific user by ID"""
    user = db.query(models.User).filter(models.User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail=f"User with id {user_id} not found")
    return user

@app.post("/users", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
def create_user(user: UserCreate, db: Session = Depends(get_db)):
    """Create a new user with validation"""
    # Check if email already exists
    existing_user = db.query(models.User).filter(models.User.email == user.email).first()
    if existing_user:
        raise HTTPException(status_code=400, detail="Email already registered")
    
    new_user = models.User(
        email=user.email,
        password=user.password,  # In production, hash this password
        first_name=user.first_name,
        last_name=user.last_name,
        is_active=user.is_active,
        is_verified=user.is_verified
    )
    db.add(new_user)
    db.commit()
    db.refresh(new_user)
    return new_user

@app.put("/users/{user_id}", response_model=UserResponse)
def update_user(user_id: int, user: UserUpdate, db: Session = Depends(get_db)):
    """Update a user with partial updates support"""
    db_user = db.query(models.User).filter(models.User.id == user_id).first()
    if not db_user:
        raise HTTPException(status_code=404, detail=f"User with id {user_id} not found")
    
    # Check if email is being updated and if it already exists
    if user.email and user.email != db_user.email:
        existing_user = db.query(models.User).filter(models.User.email == user.email).first()
        if existing_user:
            raise HTTPException(status_code=400, detail="Email already registered")
    
    # Only update provided fields
    if user.email is not None:
        db_user.email = user.email
    if user.password is not None:
        db_user.password = user.password  # In production, hash this password
    if user.first_name is not None:
        db_user.first_name = user.first_name
    if user.last_name is not None:
        db_user.last_name = user.last_name
    if user.is_active is not None:
        db_user.is_active = user.is_active
    if user.is_verified is not None:
        db_user.is_verified = user.is_verified
    
    db.commit()
    db.refresh(db_user)
    return db_user

@app.delete("/users/{user_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_user(user_id: int, db: Session = Depends(get_db)):
    """Delete a user"""
    user = db.query(models.User).filter(models.User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail=f"User with id {user_id} not found")
    
    db.delete(user)
    db.commit()
    return None

# Advanced query endpoints
@app.get("/posts/search/advanced")
def advanced_search(
    db: Session = Depends(get_db),
    title_contains: Optional[str] = Query(None, description="Title contains text"),
    content_contains: Optional[str] = Query(None, description="Content contains text"),
    published_only: bool = Query(False, description="Show only published posts"),
    sort_by: str = Query("created_at", description="Sort by field (id, title, created_at)"),
    sort_order: str = Query("desc", description="Sort order (asc, desc)")
):
    """Advanced search with multiple filters and sorting"""
    query = db.query(models.Post)
    
    # Apply filters
    if title_contains:
        query = query.filter(models.Post.title.ilike(f"%{title_contains}%"))
    
    if content_contains:
        query = query.filter(models.Post.content.ilike(f"%{content_contains}%"))
    
    if published_only:
        query = query.filter(models.Post.published == True)
    
    # Apply sorting
    if sort_by == "id":
        sort_field = models.Post.id
    elif sort_by == "title":
        sort_field = models.Post.title
    elif sort_by == "created_at":
        sort_field = models.Post.created_at
    else:
        sort_field = models.Post.created_at
    
    if sort_order.lower() == "asc":
        query = query.order_by(asc(sort_field))
    else:
        query = query.order_by(desc(sort_field))
    
    posts = query.all()
    return {"count": len(posts), "posts": posts}

@app.get("/posts/stats")
def get_posts_stats(db: Session = Depends(get_db)):
    """Get statistics about posts"""
    total_posts = db.query(models.Post).count()
    published_posts = db.query(models.Post).filter(models.Post.published == True).count()
    draft_posts = total_posts - published_posts
    
    # Get latest post
    latest_post = db.query(models.Post).order_by(desc(models.Post.created_at)).first()
    
    return {
        "total_posts": total_posts,
        "published_posts": published_posts,
        "draft_posts": draft_posts,
        "latest_post_date": latest_post.created_at if latest_post else None
    }

@app.get("/posts/recent/{limit}")
def get_recent_posts(limit: int, db: Session = Depends(get_db)):
    """Get recent posts with custom limit"""
    if limit < 1 or limit > 50:
        raise HTTPException(status_code=400, detail="Limit must be between 1 and 50")
    posts = db.query(models.Post).order_by(desc(models.Post.created_at)).limit(limit).all()
    return {"recent_posts": posts, "limit": limit}

@app.get("/posts/published")
def get_published_posts(
    db: Session = Depends(get_db),
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=1000)
):
    """Get only published posts"""
    posts = db.query(models.Post).filter(models.Post.published == True).offset(skip).limit(limit).all()
    return {"published_posts": posts, "count": len(posts)}

@app.get("/posts/drafts")
def get_draft_posts(
    db: Session = Depends(get_db),
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=1000)
):
    """Get only draft posts"""
    posts = db.query(models.Post).filter(models.Post.published == False).offset(skip).limit(limit).all()
    return {"draft_posts": posts, "count": len(posts)}

# Raw SQL query endpoint for advanced users
@app.get("/query/raw")
def execute_raw_query(
    sql_query: str = Query(..., description="Raw SQL query to execute"),
    db: Session = Depends(get_db)
):
    """Execute raw SQL queries (use with caution)"""
    try:
        # Only allow SELECT queries for security
        if not sql_query.strip().upper().startswith('SELECT'):
            raise HTTPException(status_code=400, detail="Only SELECT queries are allowed")
        
        result = db.execute(text(sql_query))
        columns = result.keys()
        rows = [dict(zip(columns, row)) for row in result.fetchall()]
        
        return {
            "query": sql_query,
            "columns": list(columns),
            "rows": rows,
            "row_count": len(rows)
        }
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Query execution failed: {str(e)}")

# Database health check
@app.get("/health")
def health_check(db: Session = Depends(get_db)):
    """Check database connection and table status"""
    try:
        # Test database connection
        db.execute(text("SELECT 1"))
        
        # Get table info
        total_posts = db.query(models.Post).count()
        total_users = db.query(models.User).count()
        
        return {
            "status": "healthy",
            "database": "connected",
            "tables": {
                "posts": {
                    "total_records": total_posts
                },
                "users": {
                    "total_records": total_users
                }
            },
            "timestamp": "2025-01-09T10:50:00Z"
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Database health check failed: {str(e)}")

# Sample data creation for testing
@app.post("/sample-data")
def create_sample_data(db: Session = Depends(get_db)):
    """Create sample posts for testing purposes"""
    sample_posts = [
        {
            "title": "Getting Started with FastAPI",
            "content": "FastAPI is a modern, fast web framework for building APIs with Python 3.7+ based on standard Python type hints.",
            "published": True
        },
        {
            "title": "PostgreSQL with SQLAlchemy",
            "content": "Learn how to integrate PostgreSQL with SQLAlchemy ORM for robust database operations in your Python applications.",
            "published": True
        },
        {
            "title": "Building REST APIs",
            "content": "A comprehensive guide to building RESTful APIs with proper HTTP methods, status codes, and data validation.",
            "published": False
        },
        {
            "title": "Database Design Best Practices",
            "content": "Essential principles for designing efficient and scalable database schemas for modern applications.",
            "published": True
        },
        {
            "title": "API Testing with Postman",
            "content": "How to effectively test your APIs using Postman, including authentication, environment variables, and automated testing.",
            "published": True
        }
    ]
    
    created_posts = []
    for post_data in sample_posts:
        new_post = models.Post(**post_data)
        db.add(new_post)
        created_posts.append(new_post)
    
    db.commit()
    
    # Refresh all posts to get IDs
    for post in created_posts:
        db.refresh(post)
    
    return {
        "message": f"Created {len(created_posts)} sample posts",
        "posts": created_posts
    }

@app.post("/sample-users")
def create_sample_users(db: Session = Depends(get_db)):
    """Create sample users for testing purposes"""
    sample_users = [
        {
            "email": "john.doe@example.com",
            "password": "hashed_password_123",  # In production, this would be properly hashed
            "first_name": "John",
            "last_name": "Doe",
            "is_active": True,
            "is_verified": True
        },
        {
            "email": "jane.smith@example.com",
            "password": "hashed_password_456",
            "first_name": "Jane",
            "last_name": "Smith",
            "is_active": True,
            "is_verified": False
        },
        {
            "email": "admin@example.com",
            "password": "admin_hashed_password",
            "first_name": "Admin",
            "last_name": "User",
            "is_active": True,
            "is_verified": True
        },
        {
            "email": "test.user@example.com",
            "password": "test_password_hash",
            "first_name": "Test",
            "last_name": "User",
            "is_active": False,
            "is_verified": False
        },
        {
            "email": "developer@example.com",
            "password": "dev_password_hash",
            "first_name": "Developer",
            "last_name": "Name",
            "is_active": True,
            "is_verified": True
        }
    ]

    created_users = []
    for user_data in sample_users:
        # Check if user already exists
        existing_user = db.query(models.User).filter(models.User.email == user_data["email"]).first()
        if existing_user:
            continue  # Skip if user already exists
        
        new_user = models.User(**user_data)
        db.add(new_user)
        created_users.append(new_user)
    
    db.commit()
    
    # Refresh all users to get IDs
    for user in created_users:
        db.refresh(user)
    
    return {
        "message": f"Created {len(created_users)} sample users",
        "users": created_users
    }

# Function to create sample data directly (for terminal use)
def create_sample_data_direct():
    """Create sample posts directly in the database"""
    from sqlalchemy.orm import sessionmaker
    
    # Create session
    SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
    db = SessionLocal()
    
    # Sample data
    sample_posts = [
        {
            'title': 'Getting Started with FastAPI',
            'content': 'FastAPI is a modern, fast web framework for building APIs with Python 3.7+ based on standard Python type hints.',
            'published': True
        },
        {
            'title': 'PostgreSQL with SQLAlchemy',
            'content': 'Learn how to integrate PostgreSQL with SQLAlchemy ORM for robust database operations in your Python applications.',
            'published': True
        },
        {
            'title': 'Building REST APIs',
            'content': 'A comprehensive guide to building RESTful APIs with proper HTTP methods, status codes, and data validation.',
            'published': False
        },
        {
            'title': 'Database Design Best Practices',
            'content': 'Essential principles for designing efficient and scalable database schemas for modern applications.',
            'published': True
        },
        {
            'title': 'API Testing with Postman',
            'content': 'How to effectively test your APIs using Postman, including authentication, environment variables, and automated testing.',
            'published': True
        }
    ]
    
    # Insert sample data
    for post_data in sample_posts:
        new_post = models.Post(**post_data)
        db.add(new_post)
    
    # Commit changes
    db.commit()
    print('Sample posts inserted successfully!')
    
    # Close session
    db.close()

def create_sample_users_direct():
    """Create sample users directly in the database"""
    from sqlalchemy.orm import sessionmaker
    
    # Create session
    SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
    db = SessionLocal()
    
    # Sample user data
    sample_users = [
        {
            'email': 'john.doe@example.com',
            'password': 'hashed_password_123',
            'first_name': 'John',
            'last_name': 'Doe',
            'is_active': True,
            'is_verified': True
        },
        {
            'email': 'jane.smith@example.com',
            'password': 'hashed_password_456',
            'first_name': 'Jane',
            'last_name': 'Smith',
            'is_active': True,
            'is_verified': False
        },
        {
            'email': 'admin@example.com',
            'password': 'admin_hashed_password',
            'first_name': 'Admin',
            'last_name': 'User',
            'is_active': True,
            'is_verified': True
        },
        {
            'email': 'test.user@example.com',
            'password': 'test_password_hash',
            'first_name': 'Test',
            'last_name': 'User',
            'is_active': False,
            'is_verified': False
        },
        {
            'email': 'developer@example.com',
            'password': 'dev_password_hash',
            'first_name': 'Developer',
            'last_name': 'Name',
            'is_active': True,
            'is_verified': True
        }
    ]
    
    # Insert sample data
    for user_data in sample_users:
        # Check if user already exists
        existing_user = db.query(models.User).filter(models.User.email == user_data['email']).first()
        if existing_user:
            print(f'User with email {user_data["email"]} already exists, skipping...')
            continue
        
        new_user = models.User(**user_data)
        db.add(new_user)
        print(f'Added user: {user_data["email"]}')
    
    # Commit changes
    db.commit()
    print('Sample users inserted successfully!')
    
    # Close session
    db.close()

# Clear all data (use with caution)
@app.delete("/clear-all")
def clear_all_data(db: Session = Depends(get_db)):
    """Clear all posts from the database (use with caution)"""
    try:
        deleted_count = db.query(models.Post).delete()
        db.commit()
        return {
            "message": f"Deleted {deleted_count} posts",
            "deleted_count": deleted_count
        }
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Failed to clear data: {str(e)}")

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8001)



models.py file
from sqlalchemy import Column, Integer, String, Boolean, column, TIMESTAMP, UniqueConstraint
from database import Base
from sqlalchemy.sql.expression import text

class Post(Base):
    __tablename__ = "posts"
    id = Column(Integer, primary_key=True, nullable=False)
    title = Column(String, nullable=False)
    content = Column(String, nullable=False)
    published = Column(Boolean, server_default='True', nullable=False)
    created_at = Column(TIMESTAMP(timezone=True), nullable=False, server_default=text('now()'))

class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, nullable=False, unique=True)
    email = Column(String, nullable=False, unique=True)
    password = Column(String, nullable=False)
    first_name = Column(String, nullable=True)
    last_name = Column(String, nullable=True)
    is_active = Column(Boolean, server_default='True', nullable=False)
    is_verified = Column(Boolean, server_default='False', nullable=False)
    created_at = Column(TIMESTAMP(timezone=True), nullable=False, server_default=text('now()'))
    updated_at = Column(TIMESTAMP(timezone=True), nullable=False, server_default=text('now()'), onupdate=text('now()'))
    
    # Additional constraint to ensure email uniqueness at database level
    __table_args__ = (
        UniqueConstraint('email', name='unique_user_email'),
    )


Database.py file
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

SQLALCHEMY_DATABASE_URL = 'postgresql://postgres:swagath12345@localhost/fastapi'
engine = create_engine(SQLALCHEMY_DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False,autoflush=False,bind=engine)
Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

def recreate_tables():
    """Drop all tables and recreate them with the new schema"""
    Base.metadata.drop_all(bind=engine)
    Base.metadata.create_all(bind=engine)
